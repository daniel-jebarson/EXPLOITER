from asyncio.windows_events import NULL
from typing import Text, Tuple
from discord import channel
from discord.colour import Color
from discord.utils import get
from dotenv import load_dotenv
import discord
from discord.ext import commands
from pymongo.read_preferences import Secondary
from pymongo.topology import process_events_queue
from troops import *
from mongodb import *
import random
import asyncio
import os
import time
import requests
import datetime
load_dotenv()  # take env variable from dot env
TOKEN = os.getenv("TOKEN")

# initialization
bot = commands.Bot(command_prefix="?")


@bot.event
async def on_ready():
    print(f"Logged in as {bot.user}")
########
# global sended_dms
# global rate_limit_for_dms
# global time_to_wait_to_avoid_rate_limit
sended_dms = 0
rate_limit_for_dms = 29  # 29
time_to_wait_to_avoid_rate_limit = 60
##########

# start of game


@bot.command(name="start")
async def start(ctx: commands.Context):
    ''' Use this command to start using the bot'''
    if user_info.find_one({'id': ctx.author.id}):  # checks user already started the game
        await ctx.reply('You have already started! For more commands use `?help`')
    else:       # if user hasn't started, adds the user to db
        userDoc = {
            'id': int(ctx.author.id),
            'name': str(ctx.author),
            'might': 0,
            't1': 0,
            't2': 0,
            't3': 0,
            'potions': 0
        }
        user_info.insert_one(userDoc)
        await ctx.reply(f'Hello! Welcome {ctx.author}!')
    #############
    global sended_dms
    sended_dms += 1
    if sended_dms % rate_limit_for_dms == 0:  # used to check if 29 dms are sent
        await ctx.send("Our bot got too much commands. Wait for sometime")
        # wait till we can continue
        asyncio.sleep(time_to_wait_to_avoid_rate_limit)
    #############


@bot.command(name="profile")  # Profile of a player
async def profile(ctx: commands.Context, enemy: discord.Member = None):
    ''' Displays might, name, avatar'''
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
    if(enemy == None):
        embedobj = discord.Embed(
            title=ctx.author
        )
        embedobj.set_thumbnail(url=ctx.author.avatar_url)
        get_data = user_info.find_one({'id': ctx.author.id})
        filtr = {'id': ctx.author.id}
        update_data = user_info.find_one_and_update
        mighter = might(get_data['t1'], get_data['t2'], get_data['t3'])
        update_data(filtr, {'$set': {'might': mighter}})
        embedobj.add_field(name='Might', value=user_info.find_one(
            {'id': ctx.author.id})['might'])
        embedobj.add_field(name='Tier 1', value=user_info.find_one(
            {'id': ctx.author.id})['t1'])
        embedobj.add_field(name='Tier 2', value=user_info.find_one(
            {'id': ctx.author.id})['t2'])
        embedobj.add_field(name='Tier 3', value=user_info.find_one(
            {'id': ctx.author.id})['t3'])
        embedobj.add_field(name='Training potions', value=user_info.find_one(
            {'id': ctx.author.id})['potions'])
        total_troops = get_data['t1']+get_data['t2']+get_data['t3']
        embedobj.add_field(name='Total troops', value=total_troops)
        await ctx.author.send(embed=embedobj)
    elif(user_info.find_one({'id': enemy.id})):
        embedobj = discord.Embed(title=enemy)
        embedobj.set_thumbnail(url=enemy.avatar_url)
        get_data_enemy = user_info.find_one({'id': enemy.id})
        filtr_enemy = {'id': enemy.id}
        update_enemy_data = user_info.find_one_and_update
        enemy_mighter = might(
            get_data_enemy['t1'], get_data_enemy['t2'], get_data_enemy['t3'])
        update_enemy_data(filtr_enemy, {'$set': {'might': enemy_mighter}})
        embedobj.add_field(name='Might', value=user_info.find_one(
            {'id': enemy.id})['might'])
        await ctx.reply(embed=embedobj)
    elif(user_info.find_one({'id': enemy.id}) == None):
        await ctx.send("The players hasn't started the game yet!")
    else:
        await ctx.send("It\'s a bug try using correct command")
    #############
    global sended_dms
    sended_dms += 1
    # print(sended_dms)
    if sended_dms % rate_limit_for_dms == 0:  # used to check if 29 dms are sent
        await ctx.send("Our bot got too much commands. Wait for sometime")
        # wait till we can continue
        asyncio.sleep(time_to_wait_to_avoid_rate_limit)
    #############


@bot.command(name='potion')
async def potion_count(ctx: commands.Context):
    ''' Sends the potion count in dm '''
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
    try:
        await ctx.author.send("You currently have "+str(user_info.find_one({'id': ctx.author.id})['potions'])+" training potions")
    except Exception as error:
        await ctx.channel.send('Please start using `?start` command if you haven\'t yet! Or it\'s a bug :(')
     #############
    global sended_dms
    sended_dms += 1
    if sended_dms % rate_limit_for_dms == 0:  # used to check if 29 dms are sent
        await ctx.send("Our bot got too much commands. Wait for sometime")
        # wait till we can continue
        asyncio.sleep(time_to_wait_to_avoid_rate_limit)
    #############


@bot.command(name="beg")  # Easier, low-prize training potions
async def beg(ctx: commands.Context):
    ''' Gives low potion (high probability)'''
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
    elif(user_info.find_one({'id': ctx.author.id})):
        trmp = random.randint(1, 2)
        if(trmp == 1):
            await ctx.reply("You got 0 training potions")
        else:
            x = random.randint(0, 1000)  # x is potions obtained in beg
            user_info.update_one({'id': ctx.author.id}, {
                                 '$inc': {'potions': +x}})
            await ctx.reply(f"Congratulations you got {x} training potions")
    else:
        await ctx.send("It\'s a bug try using correct command")
    #############
    global sended_dms
    sended_dms += 1
    if sended_dms % rate_limit_for_dms == 0:  # used to check if 29 dms are sent
        await ctx.send("Our bot got too much commands. Wait for sometime")
        # wait till we can continue
        asyncio.sleep(time_to_wait_to_avoid_rate_limit)
    #############


@bot.command(name="resources")  # Harder, high-prize training potions
async def beg(ctx: commands.Context):
    ''' Get high potions(less probability)'''
    if user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
    elif(user_info.find_one({'id': ctx.author.id})):
        trmp = random.randint(1, 4)
        if(trmp == 1):
            # x is potions obtained in resources
            x = random.randint(15, 1000)*10
            user_info.update_one({'id': ctx.author.id}, {
                                 '$inc': {'potions': +x}})
            await ctx.reply(f"Congratulations you got {x} training potions")
        else:
            await ctx.reply("You got 0 training potions")
    else:
        await ctx.send("It\'s a bug try using correct command")
    #############
    global sended_dms
    sended_dms += 1
    if sended_dms % rate_limit_for_dms == 0:  # used to check if 29 dms are sent
        await ctx.send("Our bot got too much commands. Wait for sometime")
        # wait till we can continue
        asyncio.sleep(time_to_wait_to_avoid_rate_limit)
    #############


@bot.command(name="train")  # Training the soldiers
# tier -  troop tier to train, Amount - No. of troops to train
async def training(ctx: commands.Context, tier: int = None, amount: int = None):
    ''' Used to train troops `?train <tier> <troops_amount>` Eg: ||?train 3 100||'''
    if(tier == None or amount == None):
        await ctx.send("Give the argument correctly like `?train <tier> <troops_amount>`")
    elif(user_info.find_one({'id': ctx.author.id})):
        if user_info.find_one({'id': ctx.author.id}) == None:
            await ctx.send('Please start using `?start`!')
        get_data = user_info.find_one({'id': ctx.author.id})
        update_data = user_info.find_one_and_update
        filtr = {'id': ctx.author.id}
        # print(get_data)
        res = train(amount, get_data['potions'], tier,
                    get_data['t1'], get_data['t2'], get_data['t3'])
        # if(res!="Not enough training potions" && res!="No such tier troops exist")
        if(res == "Not enough training potions"):
            await ctx.send(f'{ctx.author.mention}You dont have enough potions')
        elif(res == "No such tier troops exist"):
            await ctx.send(f'{ctx.author.mention}No such tier exists. Tiers avaliable are 1-3')
        else:
            update_data(filtr, {'$set': {
                        't1': res['tier1'], 't2': res['tier2'], 't3': res['tier3'], 'potions': res['training_train_pot']}})
            await ctx.send(f"{ctx.author.mention}You have successfully trained {amount} tier {tier} troops")
    elif(user_info.find_one({'id': ctx.author.id}) == None):
        await ctx.reply('Please start using `?start` command')
    else:
        await ctx.send("Give the argument correctly like `?train <tier> <troops_amount>`")
    #############
    global sended_dms
    sended_dms += 1
    if sended_dms % rate_limit_for_dms == 0:  # used to check if 29 dms are sent
        await ctx.send("Our bot got too much commands. Wait for sometime")
        # wait till we can continue
        asyncio.sleep(time_to_wait_to_avoid_rate_limit)
    #############


@bot.command(name="scout")  # Scouting the player
async def scout(ctx: commands.Context, enemy: discord.Member = None):
    ''' Used to scout enemy `?scout <enemy?` Eg: ||?scout @kingdomfight||'''
    if(enemy == None):
        await ctx.send('Tag someone to scout!')
    elif user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
    elif user_info.find_one({'id': enemy.id}) == None:
        await ctx.send('Player you scouted hasn\'t started using the bot')
    elif(enemy == ctx.author):
        await ctx.reply("You can't scout yourself")
    elif(user_info.find_one({'id': enemy.id})):
        fltr = {'id': enemy.id}
        data = user_info.find_one(fltr)
        em = discord.Embed(title=f'{enemy}\'s Scout Report!')
        em.add_field(name='Tier 1', value=data['t1'])
        em.add_field(name='Tier 2', value=data['t2'])
        em.add_field(name='Tier 3', value=data['t3'])
        em.add_field(name='Potions', value=data['potions'])
        total_troops = data['t1']+data['t2']+data['t3']
        em.add_field(name='Total troops', value=total_troops)
        await ctx.reply(embed=em)
        await enemy.send(f"{ctx.author} is scouting your troops")
    else:
        await ctx.send("Use `?scout <member>`")
    #############
    global sended_dms
    sended_dms += 1
    if sended_dms % rate_limit_for_dms == 0:  # used to check if 29 dms are sent
        await ctx.send("Our bot got too much commands. Wait for sometime")
        # wait till we can continue
        asyncio.sleep(time_to_wait_to_avoid_rate_limit)
    #############

# working


@bot.command(name='fight')  # fighting with others
async def fighting(ctx: commands.Context, enemy: discord.Member = None):
    ''' Used to fight enemy `?fight <enemy?` Eg: ||?fight @kingdomfight||'''
    if(enemy == None):
        await ctx.send('Tag someone to attack!')
    elif user_info.find_one({'id': ctx.author.id}) == None:
        await ctx.send('Please start using `?start`!')
    elif user_info.find_one({'id': enemy.id}) == None:
        await ctx.send('Player you trying to attack hasn\'t started using the bot')
    elif(enemy == ctx.author):
        await ctx.reply("You can't attack yourself")
    elif(user_info.find_one({'id': enemy.id})):
        author_filtr = {'id': ctx.author.id}
        author_get_data = user_info.find_one(author_filtr)
        update_data = user_info.find_one_and_update
        enemy_filtr = {'id': enemy.id}
        enemy_get_data = user_info.find_one(enemy_filtr)
        res = fight(author_get_data['t1'], author_get_data['t2'], author_get_data['t3'], author_get_data['potions'],
                    enemy_get_data['t1'], enemy_get_data['t2'], enemy_get_data['t3'], enemy_get_data['potions'])
        # print(res[0],res[1][2])
        # update_data(filtr,{'$set':{'t1':res['tier1'],'t2':res['tier2'],'t3':res['tier3'],'potions':res['training_train_pot']}})
        update_data(author_filtr, {'$set': {
                    't1': res[1][2], 't2': res[1][3], 't3': res[1][4], 'potions': res[1][5]}})
        update_data(enemy_filtr, {'$set': {
                    't1': res[1][6], 't2': res[1][7], 't3': res[1][8], 'potions': res[1][9]}})
        if(res[0] == True):
            await ctx.send(f"{ctx.author} attacked {enemy} and took the leader in chains")
            await enemy.send(f"{ctx.author} attacked you and took your leader in chains")
        else:
            await ctx.send(f"{ctx.author} attacked {enemy} and got defeated. The attacking leader got captured")
            await enemy.send(f"{ctx.author} attacked you. You won in this battle")
        tot_might_loss = res[1][0]+res[1][1]
        await ctx.send(f"Total might loss in this battle is {tot_might_loss}")
        await enemy.send(f"Total might loss in this battle is {tot_might_loss}")
    else:
        await ctx.send("Use `?fight <enemy_tag>")
    #############
    global sended_dms
    sended_dms += 1
    if sended_dms % rate_limit_for_dms == 0:  # used to check if 29 dms are sent
        await ctx.send("Our bot got too much commands. Wait for sometime")
        # wait till we can continue
        asyncio.sleep(time_to_wait_to_avoid_rate_limit)
    #############


# # going


# @bot.command(name="rich")
# async def rich(ctx):
#     for i in user_db:
#         await ctx.send()
#mights = []
# names = []
# for doc in user_info.find():
#     mights.append(doc['might'])
#     names.append(doc['name'])
# n = len(mights)
# res = {names[i]: mights[i] for i in range(n)}

# sorted_age = sorted(res.items(), key=lambda kv: kv[1])
# print(sorted_age)
# # # [('jane', 32), ('beth', 37), ('john', 41), ('mike', 59)]
# # print(res)


@bot.command(name="meme")
async def meme(ctx):
    r = requests.get("https://memes.blademaker.tv/api?lang=en")
    res = r.json()
    title = res["title"]
    ups = res["ups"]
    downs = res["downs"]
    comments = res['score']
    memes = discord.Embed(title=f"{title}")
    memes.set_image(url=res["image"])
    memes.set_footer(text=f"üëç : {ups}   üí¨ : {comments}")
    await ctx.send(embed=memes)


@bot.command(name="quote")
async def quote(ctx: commands.context, day: str = NULL):
    '''``?quote`` to get random quote and ``?quote today`` to get today's quote'''
    if(day == NULL):
        response = requests.get("https://zenquotes.io/api/random")
        zen = (response.json())
        await ctx.reply(zen[0]['q']+"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-"+zen[0]['a'])
    elif(day == "today"):
        response = requests.get("https://zenquotes.io/api/today")
        zen = response.json()
        await ctx.reply(zen[0]['q']+"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-"+zen[0]['a'])
    else:
        await ctx.reply("``?quote`` to get random quote and ``?quote today`` to get today's quote")


@bot.command(name="invite")  # invite link for the bot
async def invite(ctx):
    '''Gives the invite link of the bot'''
    await ctx.send("https://discord.com/oauth2/authorize?client_id=839421874646548530&permissions=0&scope=bot")


@bot.command(name="close")  # closes the terminal üòÅ:)
async def close(ctx):
    '''Used to stop the bot. Only available for developers üòÖ'''
    if ctx.author.id in [768016269269925911, 811919559086702642]:
        await ctx.send("Bot has been closed by a owner for now")
        await quit()
    else:
        await ctx.send('This is only for owners üòé!')


# adding
@bot.command(name="gstart")
@commands.has_role("giveaway")
async def gstart(ctx, timer: str, winner: str, *args):
    '''Used to start the giveaway in the current channel Eg:||?gstart 10s 1w dank coins||.Use (s-seconds|m-minutes|h-hour|d-day and w-winners)Giveaways require ``giveaway`` role. Ask the owner to create a role name ``giveaway`` if there is no role'''
    time = convert(timer)
    if time == -1:
        await ctx.send(f"You didn't answer the time with proper unit. Use (s-seconds|m-minutes|h-hour|d-day) next time!")
        return
    elif time == -2:
        await ctx.send(f"The time must be in integer. Please enter the integer")
        return
    if(winner[-1] == "w"):
        n = len(winner)
        y = winner[0:n-1]
        try:
            winners = int(y)
        except ValueError:
            await ctx.send(f"The winner must be in integer. Please enter the integer! Eg: 1w-for 1 winner")
            return
    else:
        y = winner
        try:
            winners = int(y)
        except ValueError:
            await ctx.send(f"The winner must be in integer. Please enter the integer! Eg: 1w-for 1 winner")
            return
    prize = ' '.join(args)
    if(timer[-1] == "s"):
        prefix = "seconds"
    elif(timer[-1] == "m"):
        prefix = "minutes"
    elif(timer[-1] == "h"):
        prefix = "hours"
    elif(timer[-1] == "d"):
        prefix = "days"
    n = len(timer)
    announce_time = timer[0:n-1]
    await ctx.send("The giveaway is starting in this channel now!!!")
    embed = discord.Embed(
        title="Giveaway!", description=f"{prize}", Color=ctx.author.color)
    embed.add_field(name="No of winners", value=winners, inline=False)
    embed.add_field(name="Hosted by: ", value=ctx.author.mention)
    embed.set_footer(text=f"Ends in {announce_time} {prefix} from now!")
    new_embed = discord.Embed(
        title="Giveaway!", description=f"{prize}", Color=ctx.author.color)
    new_embed.add_field(name="No of winners", value=winners, inline=False)
    new_embed.add_field(name="Hosted by: ", value=ctx.author.mention)
    my_msg = await ctx.send(embed=embed)
    winners_announce = ""
    await my_msg.add_reaction("üéâ")
    await asyncio.sleep(time)
    new_msg = await ctx.fetch_message(my_msg.id)
    try:
        users = await new_msg.reactions[0].users().flatten()
        users.pop(users.index(bot.user))
        counts = len(users)

        if(winners < counts or winners <= 0):
            await channel.send("Not enough members ")
            return
        winner = random.sample(users, winners)
        for i in winner:
            winners_announce += i.mention + " "
        new_embed.add_field(name="Winner is : ",
                            value=winners_announce, inline=False)
        new_embed.set_footer(text="This giveaway has been ended")
        await new_msg.edit(embed=new_embed)
        await ctx.send(f"Congratulations! {winners_announce} you won {prize}!. Total entries = {counts} entrants ‚ÜóÔ∏è")

    except:
        await ctx.send(f"The Giveaway has been cancelled because of lesser number of participants or someone cancelled the Giveaway")
        embed = discord.Embed(
            title="Giveaway!", description=f"{prize}", Color=ctx.author.color)
        embed.add_field(name="No of winners", value=winners, inline=False)
        embed.add_field(name="Hosted by: ", value=ctx.author.mention)
        embed.set_footer(text=f"Giveaway closed due to less participants!")
        await new_msg.edit(embed=new_embed)


@bot.command(name="gcreate")
@commands.has_role("giveaway")
async def gcreate(ctx):
    '''Used to start the giveaway in the any channel Eg:||?gcreate #giveaway 10s 1w dank coins||.Use (s-seconds|m-minutes|h-hour|d-day and w-winners)Giveaways require ``giveaway`` role. Ask the owner to create a role name ``giveaway`` if there is no role'''
    await ctx.send("Let's start the giveaway! Answer these questions within 30 seconds")
    questions = ["Which channel should the giveaway be hosted in?",
                 "What should be the duration of the giveaway? (s-seconds|m-minutes|h-hour|d-day)",
                 "Number of winners in the giveaway?",
                 "What is the prize of the giveaway?"]
    answers = []

    def check(m):
        return m.author == ctx.author and m.channel == ctx.channel
    for i in questions:
        await ctx.send(i)
        try:
            msg = await bot.wait_for('message', timeout=30.0, check=check)
        except asyncio.TimeoutError:
            await ctx.send("You didn't answered in time, please answer at next time!")
            return
        else:
            answers.append(msg.content)
    try:
        c_id = int(answers[0][2:-1])
    except:
        await ctx.send(f"You didn't mention a channel correctly.Do it like this {ctx.channel.mention} next time")
        return

    channel = bot.get_channel(c_id)
    time = convert(answers[1])
    if time == -1:
        await ctx.send(f"You didn't answer the time with proper unit. Use (s-seconds|m-minutes|h-hour|d-day) next time!")
        return
    elif time == -2:
        await ctx.send(f"The time must be in integer. Please enter the integer")
        return
    no_winners = answers[2]
    prize = answers[3]
    if(no_winners.isnumeric() == True):
        no_winners = int(no_winners)
    else:
        await channel.send("you gave non-integer values for winners")
        return
    if(answers[1][-1] == "s"):
        prefix = "seconds"
    elif(answers[1][-1] == "m"):
        prefix = "minutes"
    elif(answers[1][-1] == "h"):
        prefix = "hours"
    elif(answers[1][-1] == "d"):
        prefix = "days"
    n = len(answers[1])
    announce_time = answers[1][0:n-1]
    await ctx.send(f"The Giveaway will be in channel {channel.mention} and will last {answers[1]} !")

    embed = discord.Embed(
        title="Giveaway!", description=f"{prize}", Color=ctx.author.color)
    embed.add_field(name="No of winners", value=no_winners, inline=False)
    embed.add_field(name="Hosted by: ", value=ctx.author.mention)
    embed.set_footer(text=f"Ends in {announce_time} {prefix} from now!")

    new_embed = discord.Embed(
        title="Giveaway!", description=f"{prize}", Color=ctx.author.color)
    new_embed.add_field(name="No of winners", value=no_winners, inline=False)
    new_embed.add_field(name="Hosted by: ", value=ctx.author.mention)

    my_msg = await channel.send(embed=embed)
    winners = ""
    await my_msg.add_reaction("üéâ")
    await asyncio.sleep(time)
    new_msg = await channel.fetch_message(my_msg.id)
    try:
        users = await new_msg.reactions[0].users().flatten()
        users.pop(users.index(bot.user))
        counts = len(users)

        if(no_winners < counts or no_winners <= 0):
            await channel.send("Not enough members ")
            return
        winner = random.sample(users, no_winners)
        for i in winner:
            winners += i.mention + " "
        new_embed.add_field(name="Winner is : ",
                            value=winners, inline=False)
        new_embed.set_footer(text="This giveaway has been ended")
        await new_msg.edit(embed=new_embed)
        await channel.send(f"Congratulations! {winners} you won {prize}!. Total entries = {counts} entrants ‚ÜóÔ∏è")

    except:
        await channel.send(f"The Giveaway has been cancelled because of lesser number of participants or someone cancelled the Giveaway")
        embed = discord.Embed(
            title="Giveaway!", description=f"{prize}", Color=ctx.author.color)
        embed.add_field(name="No of winners", value=no_winners, inline=False)
        embed.add_field(name="Hosted by: ", value=ctx.author.mention)
        embed.set_footer(text=f"Giveaway closed due to less participants!")
        await new_msg.edit(embed=new_embed)


@bot.command(name="greroll")
@commands.has_role("giveaway")
async def greroll(ctx, channel: discord.TextChannel, id_: int):
    '''Used to reroll the giveaway in the current channel Eg:||?greroll #channel-id(of the required giveaway) #id of the required giveaway||Giveaways require ``giveaway`` role. Ask the owner to create a role name ``giveaway`` if there is no role. Don't reroll while the giveaway is ongoing'''
    try:
        new_msg = await channel.fetch_message(id_)
    except:
        await ctx.send("The id was entered incorrectly")
        return
    winners = ""
    winner_lst = str(new_msg.embeds[0].fields[0])
    winner_value = int(winner_lst.split("'")[3])
    host_lst = str(new_msg.embeds[0].fields[1])
    host_value = host_lst.split("'")[3]
    prize = new_msg.embeds[0].description
    users = await new_msg.reactions[0].users().flatten()
    users.pop(users.index(bot.user))
    counts = len(users)
    winner = random.sample(users, winner_value)
    for i in winner:
        winners += i.mention + " "
    new_embed = discord.Embed(
        title="Giveaway!", description=f"{prize}", Color=ctx.author.color)
    new_embed.add_field(name="No of winners", value=winner_value, inline=False)
    new_embed.add_field(name="Hosted by: ", value=host_value, inline=False)
    new_embed.add_field(name="Winner is : ",
                        value=winners, inline=False)
    new_embed.set_footer(text="This giveaway has been ended")
    await new_msg.edit(embed=new_embed)
    await channel.send(f"Congratulations! {winners} you won {prize} !. Total entries = {counts} entrants ‚ÜóÔ∏è")


bot.run(TOKEN)
